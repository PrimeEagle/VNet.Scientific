// ReSharper disable UnusedMember.Global

// ReSharper disable MemberCanBeMadeStatic.Local
// ReSharper disable ParameterTypeCanBeEnumerable.Local
// ReSharper disable SuggestBaseTypeForParameter
// ReSharper disable SuggestBaseTypeForParameterInConstructor
#pragma warning disable CA1822
namespace VNet.Scientific.Noise.Other;
// Harmonic noise is characterized by the presence of noise components that are harmonically related to a fundamental frequency.
// It can arise from nonlinear distortion or interference in electrical or audio systems. Harmonic noise can be generated by introducing
// noise at specific harmonic frequencies.
public class HarmonicNoise : NoiseBase
{
    public HarmonicNoise(IHarmonicNoiseAlgorithmArgs args) : base(args)
    {
    }

    public override double[] GenerateRaw()
    {
        var dimensions = Args.Dimensions;
        var numHarmonics = ((IHarmonicNoiseAlgorithmArgs)Args).Frequencies.Length;

        var result = new double[GetTotalSize(dimensions)];

        for (var i = 0; i < GetTotalSize(dimensions); i++)
        {
            var indices = ConvertIndexToNDimensional(i, dimensions);

            var noiseValue = 0.0;
            for (var h = 0; h < numHarmonics; h++)
            {
                var frequency = ((IHarmonicNoiseAlgorithmArgs)Args).Frequencies[h];
                var amplitude = ((IHarmonicNoiseAlgorithmArgs)Args).Amplitudes[h];

                double phase = 0.0;
                for (var dim = 0; dim < dimensions.Length; dim++)
                {
                    phase += 2.0 * Math.PI * frequency * indices[dim] / ((IHarmonicNoiseAlgorithmArgs)Args).SampleRate;
                }
                noiseValue += amplitude * Math.Sin(phase);
            }

            result[i] = noiseValue * Args.Scale;
        }

        return result;
    }
    public override double GenerateSingleSampleRaw()
    {
        throw new NotImplementedException("Generating a single sample is not supported for HarmonicNoise.");
    }

    private int GetTotalSize(int[] dimensions)
    {
        return dimensions.Aggregate(1, (a, b) => a * b);
    }

    private int[] ConvertIndexToNDimensional(int index, int[] dimensions)
    {
        var indices = new int[dimensions.Length];
        for (var i = 0; i < dimensions.Length; i++)
        {
            indices[i] = index % dimensions[i];
            index /= dimensions[i];
        }
        return indices;
    }
}